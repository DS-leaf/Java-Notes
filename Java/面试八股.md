# Java面试八股
[toc]
## Java基础
### Java语言有哪些特点？
+ 面向对象（**封装，继承，多态**）；
+ 平台无关性，具体表现在Java 是“一次编写，到处运行”的语言，因此采用 Java 语言编写的程序具有很好的**可移植性**，而保证这一点的正是 **Java 的虚拟机机制**。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。
+ 支持多线程。C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；
+ 支持网络编程并且很方便。
+ 编译与解释并存。
&nbsp;
### Java和C++有什么关系，它们有什么区别？
+ 都是面向对象的语言，都支持封装、继承和多态；
+ C++ 支持指针，而 Java 没有指针的概念；
+ C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口；
+ Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。
+ Java 不支持操作符重载，操作符重载则被认为是 C++ 的突出特征；
+ Java 是完全面向对象的语言，并且还取消了 C/C++ 中的结构和联合，使编译程序更加简洁；
+ C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的；
+ goto 语句是 C 和 C++ 的“遗物”，Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读；
&nbsp;
### JVM、JRE和JDK的关系是什么？
+ JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。
+ JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。
+ JVM是Java虚拟机（Java Virtual Machine，JVM）是Java平台的核心组成部分之一，它是一个在计算机上运行Java字节码的虚拟机。JVM充当了Java应用程序和底层操作系统之间的中间层，提供了跨平台的特性，使得Java程序可以在不同的操作系统和硬件上运行。
+ JDK包含JRE，JRE包含JVM。
&nbsp;
### Java 是编译执行的语言，还是解释执行的语言?
+ 半编译，半解释：java的编译器先将其编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；
&nbsp;
### Java 中是否可以重写（覆盖）⼀个 private 或者 static ⽅法？
+ Java 中 static ⽅法不能被覆盖，因为⽅法覆盖是基于运⾏时动态绑定的，⽽ static ⽅法是编译时静态绑定的。static ⽅法跟类的任何实例都不相关，所以概念上不适⽤。
+ Java 中也不可以覆盖 private 的⽅法，因为 private 修饰的变量和⽅法只能在当前类中使⽤， 如果是其他的类继承,当前类是不能访问到 private 变量或⽅法的，当然也不能覆盖。
+ static静态⽅法补充：静态的⽅法可以被继承，但是不能重写。如果⽗类和⼦类中存在同样名称和参数的静态⽅法，那么该⼦类的⽅法会把原来继承过来的⽗类的⽅法隐藏，⽽不是重写。通俗的讲就是⽗类的⽅法和⼦类的⽅法是两个没有关系的⽅法，具体调⽤哪⼀个⽅法是看是哪个对象的引⽤；这种⽗⼦类⽅法也不在存在多态的性质。
&nbsp;
### java静态变量、代码块、和静态方法的执行顺序是什么？
+ 基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块
+ 代码块执行顺序静态代码块——> 构造代码块 ——> 构造函数——> 普通代码块
+ 继承中代码块执行顺序：父类静态块——>子类静态块——>父类代码块——>父类构造器——>子类代码块——>子类构造器
    [Static静态代码块以及各代码块之间的执行顺序](https://juejin.cn/post/6844903986475040781)
&nbsp;
### Java向上转型和向下转型
+ 向上转型：将子类对象实例化为父类对象，属于自动转换，父类只能调用父类方法或子类覆盖后的方法，无法调用子类中单独的方法。
+ 向下转型：将父类对象实例化为子类对象，属于强制转换，通过将父类强制转换为子类，从而调用子类独有的方法，为保障向下转型过程顺利，可以使用instanceof方法判断对象是否为某类的实例。
### Java语言是如何实现多态的？
+ 多态包含两种：**编译时多态（又称静态多态）**，**运行时多态（又称动态多态）**
+ Java中的 **编译时多态（又称静态多态）** 通过方法重载来实现，编译时多态在编译时就已经确定，运行的时候 **调用的是确定的方法** 。
+ Java中的 **运行时多态（又称动态多态）** 通过方法重写来实现​，编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定，Java实现多态有 3 个必要条件：**继承、重写和向上转型**。
&nbsp;
### java 创建对象有哪几种方式？
1. **new创建新对象**
2. **通过反射机制** [Java反射机制-十分钟搞懂](https://zhuanlan.zhihu.com/p/405325823)
    知道类或对象的具体信息，此时直接对类和对象进行操作即可，如果编译不知道类或对象的具体信息，这时就要用到 **反射** 来实现。动态获取类的信息。
    原理：![v2-12ed9f48c94e5e2a3c63b2ed9bc964b9_r](/assets/v2-12ed9f48c94e5e2a3c63b2ed9bc964b9_r.jpg)
    例子：
    ```java
    public class Test {
    public static void main(String[] args) throws Exception {
        //编码/编译的时候，已经知道要创建哪个类的对象，此时和反射没关系
            //创建对象
            //Animal an = new Dog();
            Animal an = new Cat();
            //操作属性
            an.nickName ="旺财";
            an.color = "黑色";
            //执行方法
            an.shout();
            an.shout("门口");
            an.run();
             System.out.println(an);
        //编码/编译的时候，不知道要创建哪个类的对象，只有根据运//行时动态获取的内容来创建对象
            //使用Properties类读取属性文件，最终得到了类的完整路径字符串
            String className = "com.bjsxt.why.Cat";
            //创建对象
            //Animal an2 = new "com.bjsxt.why.Cat"();
            Class clazz = Class.forName(className);
            Object an2 = clazz.newInstance();
            //操作属性
            //执行方法
        }
    }
    ```
    1. **优点**：
        在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。
    2. **缺点**：
        （1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；
        （2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
    &nbsp;
3. **采用clone机制**
    + 克隆对象和原对象不是同一个对象,占用不同的内存地址
    + 克隆对象和原对象应该具有相同的类型，但它不是强制性的
    + 克隆对象和原对象使用equals()方法比较应该是相等的，但它不是强制性的
    + 因为每个类的基类都是Object,所以都有clone方法,但是它是protected,所以不能在类外访问克隆一个对象,**需要对clone重写**
    1. 浅克隆：原对象和克隆对象不同,但对象内的成员引用相同
    2. 深克隆：原对象和克隆对象不同,且对象内的成员引用也不同
    > 不同:不是同一个对象,所占内存地址不同
    成员引用类中为引用类型的成员

    例子：
    **浅克隆**：
    ```java
    //学生类
    public class Student implements Cloneable{
        private String name;
        private Integer age;
        private Bag bag;
    
        public Student(String name,Integer age,Bag bag) {
            this.name = name;
            this.age = age;
            this.bag = bag;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Integer getAge() {
            return age;
        }
    
        public void setAge(Integer age) {
            this.age = age;
        }
    
        public Bag getBag() {
            return bag;
        }
    
         public void setBag(Bag bag) {
            this.bag = bag;
        }
    
        @Override
        public Student clone(){
            Student stu = null;
            try{
                stu = (Student)super.clone();
            } catch (CloneNotSupportedException e){
                e.printStackTrace();
            }
            return stu;
        }
    
        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    ", bag=" + bag.getName() +
                    '}';
        }
    }
    //背包类
    public class Bag {
        private String name;
    
        public Bag(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args){
            Student stu1 = new Student("小明",25,new Bag("小明的背包"));
            Student stu2 = stu1.clone();
            System.out.println("两对象是否相等");
            System.out.println("stu1 == stu2 "+(stu1 == stu2));
            System.out.println("stu1 "+stu1.toString());
            System.out.println("stu2 "+stu2.toString());
            System.out.println("对象内引用成员是否相等");
            System.out.println("stu1.name ==  stu2.name "+ (stu1.getName() ==  stu2.getName()));
            System.out.println("stu1.age ==  stu2.age "+(stu1.getAge() ==  stu2.getAge()));
            System.out.println("stu1.bag ==  stu2.bag "+(stu1.getBag() ==  stu2.getBag()));
        }
    }
    ```
    输出：
    ```
    两对象是否是同一对象
    stu1 == stu2 false
    stu1 Student{name='小明', age=25, bag=小明的背包}
    stu2 Student{name='小明', age=25, bag=小明的背包}
    对象内引用成员是否相等
    stu1.name ==  stu2.name true
    stu1.age ==  stu2.age true
    stu1.bag ==  stu2.bag true
    ```
    可看出,原对象和克隆对象不是同一对象,克隆对象内的值与原对象相同;对象内引用成员相等,说明只做了引用克隆,不同引用指向同一对象。
    &nbsp;
    **深克隆**：
    1. **多层实现Cloneable类**
        让上述的Bag类也实现Cloneable类,并重写clone方法
        ```java
        public class Bag implements Cloneable{
            private String name;
            public Bag(String name) {
                this.name = name;
            }
            public String getName() {
                return name;
            }
            public void setName(String name) {
                this.name = name;
            }
            @Override
            public Bag clone(){
                Bag bag= null;
                try{
                    bag= (Bag )super.clone();
                } catch (CloneNotSupportedException e){
                    e.printStackTrace();
                }
                return bag;
            }
        }
        ```
        且在Student类的clone方法中执行Bag的clone方法
        ```java
        @Override
        public Student clone(){
            Student stu = null;
            try{
                //浅克隆
                stu = (Student)super.clone();
            } catch (CloneNotSupportedException e){
                e.printStackTrace();
            }
            //深克隆
            stu.bag = (Bag)bag.clone();
            return stu;
        }
        ```
        这样便可实现深克隆,但这种方法很麻烦,若Bag类中还含有成员引用,则又需要再让它实现Cloneable接口重写clone方法,这样代码会显得很臃肿,且繁琐。
        &nbsp;
    2. **利用序列化和反序列化**
        ```java
        public class Student implements Serializable {
            private String name;
            private Integer age;
            private Bag bag;
            ...
            public Student myClone(){
                Student stu = null;
                try {
                    //将对象序列化到流里
                    ByteArrayOutputStream os = new ByteArrayOutputStream();
                    ObjectOutputStream oos = new ObjectOutputStream(os);
                    oos.writeObject(this);
                    //将流反序列化成对象
                    ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
                    ObjectInputStream ois = new ObjectInputStream(is);
                    stu = (Student) ois.readObject();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                }
                return stu;
            }
        }
        ```
        需要注意的是成员引用也需要实现Serializable接口
        ```java
        public class Bag implements Serializable {...}
        ```
        这种方法是利用序列化对象后可将其拷贝到流里,而原对象仍在jvm中,然后从流中将其反序列化成另一个对象到jvm中,从而实现深克隆
        >Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。
        
    
4. **通过序列化机制**
    Serializable序列化是将对象转成易于持久化、传输的格式的一种手段，通过将一个对象继承Serializable接口声明该类是可序列化的，然后通过ObjectOutputStream、ObjectInputStream流实现对象的存储与读取、
    &nbsp;
    1. Serializable序列化：
        ```java
        public static void main(String[] args) {
            List<User> userList = new ArrayList<User>();
            userList.add(new User(1, "张三"));
            userList.add(new User(2, "李四"));
            try {
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(userList);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        ```
        执行完成后可在项目根目录看到文件UserSerializeFile。因为是以**二进制的形式进行保存**的，所以以普通文本的形式打开会显示乱码的形式。
        &nbsp;
    2. Serializable反序列化
        ```java
        public static void main(String[] args) {
            try {
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);
                List<User> list = (List<User>) inputStream.readObject();
                for (User user : list) {
                    System.out.println("id: " + user.getId() + " userName: " + user.getUserName());
                }
                inputStream.close();
                fileInputStream.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        ```
        &nbsp;
    3. 部分字段不想序列化，怎么办？
        声明字段时使用transient关键字。无论是序列化还是反序列化，只有添加了transient，序列化运行时会跳过该字段的处理。
        &nbsp;
    4. 要进行序列化的类里的引用，是否需要可序列化？
        需要。要进行序列化的类里如果有引用对象，该对象也需要声明为可序列，即便该对象只含有基本类型的属性，否则会报错误NotSerializableException。
        &nbsp;
    5. 关于序列化多次的问题
        1. 多个对象依次序列化，可以按顺序反序列化取出。:
            ```java
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                //序列化
                User user1 = new User(1, "张三");
                User user2 = new User(2, "李四");
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(user1);
                objOutputStream.writeObject(user2);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");

                //反序列化
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStrea(fileInputStream);
                User user3 = (User)inputStream.readObject();
                User user4 = (User)inputStream.readObject();
                System.out.println("id: " + user3.getId() + " userName: " + user3.getUserName());
                System.out.println("id: " + user4.getId() + " userName: " + user4.getUserName());
                inputStream.close();
                fileInputStream.close();
            }
            ```
            结果：
            ```
            id: 1 name: 张三
            id: 2 name: 李四
            ```
        2. 一个对象序列化后修改属性后再次序列化，结果则是最初的对象属性。
            ```java
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                //序列化
                User user1 = new User(1, "张三");
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(user1);
                user1.setUserName("李四");
                objOutputStream.writeObject(user1);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");
            
                //反序列化
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);
                User user3 = (User)inputStream.readObject();
                User user4 = (User)inputStream.readObject();
                System.out.println("id: " + user3.getId() + " userName: " + user3.getUserName());
                System.out.println("id: " + user4.getId() + " userName: " + user4.getUserName());
                inputStream.close();
                fileInputStream.close();
            }
            ```
            结果：
            ```
            id: 1 name: 张三
            id: 1 name: 张三
            ```
            **原因**：
            所有要序列化的对象都有一个序列化的编码号，当试图序列化一个对象，会检查这个对象是否已经序列化过，若从未序列化过，才会序列化为字节序列去输出。若已经序列化过，则会输出一个编码符号，不会重复序列化一个对象。

    6. Externalizable
        1. **Externalizable用法**：
             创建一个ExternalizableDemo类：
            ```java
            import java.io.Externalizable;
            import java.io.IOException;
            import java.io.ObjectInput;
            import java.io.ObjectOutput;

            public class ExternalizableDemo implements Externalizable {
                private static final long serialVersionUID = 1L;
                private String name;
                private int number;

                @Override
                public void writeExternal(ObjectOutput out) throws IOException {
                    out.writeUTF(name);
                    out.writeInt(number);
                }

                @Override
                public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
                    this.name = in.readUTF();
                    this.number = in.readInt();
                }

                public String getName(){
                    return this.name;
                }

                public void setName(String name){
                    this.name = name;
                }

                public int getNumber(){
                    return this.number;
                }

                public void setNumber(int number){
                    this.number = number;
                }
            }
            ```
            定义了一个实现Externalizable接口的 ExternalizableDemo类，在该类中重写了writeExternal()和writeInt()方法
            测试对象序列化和反序列化：
            ```java
            import java.io.*;

            public class ExternalizableTest {
               public static void main(String[] args) {
                   ...
               }

               public static void testExternalizable(String OUTPUT_FILE) throws IOException, ClassNotFoundException {
                   ExternalizableDemo demo = new ExternalizableDemo();
                   demo.setNumber(1004);
                   demo.setName("JIH");
                   ExternalizableDemo seg = new ExternalizableDemo();
            
                   FileOutputStream fileOutputStream = new FileOutputStream(OUTPUT_FILE);
                   ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                   demo.writeExternal(objectOutputStream);

                   objectOutputStream.flush();
                   objectOutputStream.close();
                   fileOutputStream.close();

                   FileInputStream fileInputStream = new FileInputStream(OUTPUT_FILE);
                   ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                   seg.readExternal(objectInputStream);
            
                   objectInputStream.close();
                   fileInputStream.close();
               }
            }
            ```

        2. Externalizable与Serializable的异同
            1. 序列化内容
            Externalizable自定义序列化可以控制序列化的过程和决定哪些属性不被序列化。
            &nbsp;
            2. Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器的
            &nbsp;
            3. 使用Externalizable时，必须按照写入时的确切顺序读取所有字段状态。否则会产生异常。例如，如果更改ExternalizableDemo类中的number和name属性的读取顺序，则将抛出java.io.EOFException。而Serializable接口没有这个要求。
### 什么是不可变对象?好处坏处是什么?
+ 不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类；
+ 不可变对象最大的好处是**线程安全**；
+ 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象,**制造大量垃圾**，由于他们不能被重用而且对于它们的使用就是“用”然后“扔”，会创造很多的垃圾，给垃圾收集带来很大的麻烦

### 值传递和引用传递的区别的什么？为什么说Java中只有值传递？
+ 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

+ 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

+ 基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，**只不过“值”为对应的引用**。

### == 和 equals 区别是什么？
1. **==**:
    + 如果==比较的是基本数据类型，那么比较的是两个基本数据类型的值是否相等；
    + 如果==是比较的两个对象，那么比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域；

2. **equals**:
    + equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象
        + 情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
        + 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。

    + java语言规范要求equals方法具有以下特性：
        + **自反性**。对于任意不为null的引用值x，x.equals(x)一定是true。
        + **对称性**。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。
        + **传递性**。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。
        + **一致性**。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。
        + 对于任意不为null的引用值x，**x.equals(null)返回false**。
    
### 为什么要有 hashCode?
+ 以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：
    + 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。
    &nbsp;
    + 但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

### hashCode(),equals()两种方法是什么关系?
+ 如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。
+ 如果两个对象不 equals，他们的 hashCode 有可能相等。
+ 如果两个对象 hashCode 相等，他们不一定 equals。
+ 如果两个对象 hashCode 不相等，他们一定不 equals

### 为什么重写 equals 方法必须重写 hashcode 方法？
+ 因为判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。
&nbsp;
+ 在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。

### String,StringBuffer, StringBuilder 的区别是什么？
||String|StringBuffer|StringBuilder
|-|-|-|-
|**可变性**|不可变|可变|可变
|**执行速度**|最慢|其次|最快
|**线程安全**|安全|安全|不安全
|**使用场景**|少量字符串使用|多线程环境下的大量操作|单线程环境下的大量操作
+ **String:** String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去。
+ **StirngBuffer:** StringBuffer相对于StringBuilder效率要相对低一点，但也远比String要高的多。效率低的原因：对于StringBuffer来说更多的考虑到了多线程的情况，在进行字符串操作的时候，它**使用了synchronize关键字**，对方法进行了同步处理。
因此StringBuffer适用于多线程环境下的大量操作。
+ **StringBuilder:** 对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程的环境下对同一个StringBuilder对象进行操作。
因此StringBuilder适用于单线程环境下的大量字符串操作。

### String为什么要设计成不可变的？
1. 便于实现字符串池（String pool）
    在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了**String pool**的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。
    如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！
    &nbsp;
2. 使多线程安全
    在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。
    &nbsp;
3. 避免安全问题
    在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。
    &nbsp;
4. 加快字符串处理速度
    由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。

### 什么是字符串常量池？
+ jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。
+ 全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。

### String str="aaa"与 String str=new String("aaa")一样吗？new String(“aaa”);创建了几个字符串对象?
+ 使用String a = “aaa” ;程序运行时会**在字符串常量池中查找“aaa”字符串**，若没有，会将“aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。
+ 使用String b = new String("aaa");`，程序**会在堆内存中开辟一片新空间存放新对象**，同时会将“aaa”字符串放入常量池，相当于**创建了两个对象**，无论常量池中有没有“aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。

### intern()方法
+ 当调用 intern() 方法时，如果字符串池中已经存在相同内容的字符串，则返回字符串池中的引用；否则，将该字符串添加到字符串池中，并返回对字符串池中的新引用。

+ 例：
    ```java
    String a = new String("ab");
    String b = new String("ab");
    String c = "ab";
    String d = "a" + "b";
    String e = "b";
    String f = "a" + e;

    System.out.println(b.intern() == a);
    System.out.println(b.intern() == c);
    System.out.println(b.intern() == d);
    System.out.println(b.intern() == f);
    System.out.println(b.intern() == a.intern());
    ```
    运行结果：
    ```
    false
    true
    true
    false
    true
    ```
    由运行结果可以看出来，b.intern() == a和b.intern() == c可知，**采用new 创建的字符串对象不进入字符串池，** 并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，**如果其中含有变量（如f中的e）则不会进入字符串池中**。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。

### 在使用 HashMap 的时候，用 String 做 key 有什么好处？
HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。