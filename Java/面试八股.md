# Java面试八股
[toc]
## Java基础
### Java语言有哪些特点？
+ 面向对象（**封装，继承，多态**）；
+ 平台无关性，具体表现在Java 是“一次编写，到处运行”的语言，因此采用 Java 语言编写的程序具有很好的**可移植性**，而保证这一点的正是 **Java 的虚拟机机制**。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。
+ 支持多线程。C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；
+ 支持网络编程并且很方便。
+ 编译与解释并存。
&nbsp;
### Java和C++有什么关系，它们有什么区别？
+ 都是面向对象的语言，都支持封装、继承和多态；
+ C++ 支持指针，而 Java 没有指针的概念；
+ C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口；
+ Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。
+ Java 不支持操作符重载，操作符重载则被认为是 C++ 的突出特征；
+ Java 是完全面向对象的语言，并且还取消了 C/C++ 中的结构和联合，使编译程序更加简洁；
+ C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的；
+ goto 语句是 C 和 C++ 的“遗物”，Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读；
&nbsp;
### JVM、JRE和JDK的关系是什么？
+ JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。
+ JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。
+ JVM是Java虚拟机（Java Virtual Machine，JVM）是Java平台的核心组成部分之一，它是一个在计算机上运行Java字节码的虚拟机。JVM充当了Java应用程序和底层操作系统之间的中间层，提供了跨平台的特性，使得Java程序可以在不同的操作系统和硬件上运行。
+ JDK包含JRE，JRE包含JVM。
&nbsp;
### Java 是编译执行的语言，还是解释执行的语言?
+ 半编译，半解释：java的编译器先将其编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；
&nbsp;
### Java 中是否可以重写（覆盖）⼀个 private 或者 static ⽅法？
+ Java 中 static ⽅法不能被覆盖，因为⽅法覆盖是基于运⾏时动态绑定的，⽽ static ⽅法是编译时静态绑定的。static ⽅法跟类的任何实例都不相关，所以概念上不适⽤。
+ Java 中也不可以覆盖 private 的⽅法，因为 private 修饰的变量和⽅法只能在当前类中使⽤， 如果是其他的类继承,当前类是不能访问到 private 变量或⽅法的，当然也不能覆盖。
+ static静态⽅法补充：静态的⽅法可以被继承，但是不能重写。如果⽗类和⼦类中存在同样名称和参数的静态⽅法，那么该⼦类的⽅法会把原来继承过来的⽗类的⽅法隐藏，⽽不是重写。通俗的讲就是⽗类的⽅法和⼦类的⽅法是两个没有关系的⽅法，具体调⽤哪⼀个⽅法是看是哪个对象的引⽤；这种⽗⼦类⽅法也不在存在多态的性质。
&nbsp;
### java静态变量、代码块、和静态方法的执行顺序是什么？
+ 基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块
+ 代码块执行顺序静态代码块——> 构造代码块 ——> 构造函数——> 普通代码块
+ 继承中代码块执行顺序：父类静态块——>子类静态块——>父类代码块——>父类构造器——>子类代码块——>子类构造器
    [Static静态代码块以及各代码块之间的执行顺序](https://juejin.cn/post/6844903986475040781)
&nbsp;
### Java向上转型和向下转型
+ 向上转型：将子类对象实例化为父类对象，属于自动转换，父类只能调用父类方法或子类覆盖后的方法，无法调用子类中单独的方法。
+ 向下转型：将父类对象实例化为子类对象，属于强制转换，通过将父类强制转换为子类，从而调用子类独有的方法，为保障向下转型过程顺利，可以使用instanceof方法判断对象是否为某类的实例。
### Java语言是如何实现多态的？
+ 多态包含两种：**编译时多态（又称静态多态）**，**运行时多态（又称动态多态）**
+ Java中的 **编译时多态（又称静态多态）** 通过方法重载(Overload)来实现，编译时多态在编译时就已经确定，运行的时候 **调用的是确定的方法** 。
+ Java中的 **运行时多态（又称动态多态）** 通过方法重写(Override)来实现​，编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定，Java实现多态有 3 个必要条件：**继承、重写和向上转型**。
&nbsp;
### java 创建对象有哪几种方式？
1. **new创建新对象**
2. **通过反射机制** [Java反射机制-十分钟搞懂](https://zhuanlan.zhihu.com/p/405325823)
    知道类或对象的具体信息，此时直接对类和对象进行操作即可，如果编译不知道类或对象的具体信息，这时就要用到 **反射** 来实现。动态获取类的信息。
    原理：![v2-12ed9f48c94e5e2a3c63b2ed9bc964b9_r](/assets/v2-12ed9f48c94e5e2a3c63b2ed9bc964b9_r.jpg)
    例子：
    ```java
    public class Test {
    public static void main(String[] args) throws Exception {
        //编码/编译的时候，已经知道要创建哪个类的对象，此时和反射没关系
            //创建对象
            //Animal an = new Dog();
            Animal an = new Cat();
            //操作属性
            an.nickName ="旺财";
            an.color = "黑色";
            //执行方法
            an.shout();
            an.shout("门口");
            an.run();
             System.out.println(an);
        //编码/编译的时候，不知道要创建哪个类的对象，只有根据运//行时动态获取的内容来创建对象
            //使用Properties类读取属性文件，最终得到了类的完整路径字符串
            String className = "com.bjsxt.why.Cat";
            //创建对象
            //Animal an2 = new "com.bjsxt.why.Cat"();
            Class clazz = Class.forName(className);
            Object an2 = clazz.newInstance();
            //操作属性
            //执行方法
        }
    }
    ```
    1. **优点**：
        在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。
    2. **缺点**：
        （1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；
        （2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
    &nbsp;
3. **采用clone机制**
    + 克隆对象和原对象不是同一个对象,占用不同的内存地址
    + 克隆对象和原对象应该具有相同的类型，但它不是强制性的
    + 克隆对象和原对象使用equals()方法比较应该是相等的，但它不是强制性的
    + 因为每个类的基类都是Object,所以都有clone方法,但是它是protected,所以不能在类外访问克隆一个对象,**需要对clone重写**
    1. 浅克隆：原对象和克隆对象不同,但对象内的成员引用相同
    2. 深克隆：原对象和克隆对象不同,且对象内的成员引用也不同
    > 不同:不是同一个对象,所占内存地址不同
    成员引用类中为引用类型的成员

    例子：
    **浅克隆**：
    ```java
    //学生类
    public class Student implements Cloneable{
        private String name;
        private Integer age;
        private Bag bag;
    
        public Student(String name,Integer age,Bag bag) {
            this.name = name;
            this.age = age;
            this.bag = bag;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Integer getAge() {
            return age;
        }
    
        public void setAge(Integer age) {
            this.age = age;
        }
    
        public Bag getBag() {
            return bag;
        }
    
         public void setBag(Bag bag) {
            this.bag = bag;
        }
    
        @Override
        public Student clone(){
            Student stu = null;
            try{
                stu = (Student)super.clone();
            } catch (CloneNotSupportedException e){
                e.printStackTrace();
            }
            return stu;
        }
    
        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    ", bag=" + bag.getName() +
                    '}';
        }
    }
    //背包类
    public class Bag {
        private String name;
    
        public Bag(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args){
            Student stu1 = new Student("小明",25,new Bag("小明的背包"));
            Student stu2 = stu1.clone();
            System.out.println("两对象是否相等");
            System.out.println("stu1 == stu2 "+(stu1 == stu2));
            System.out.println("stu1 "+stu1.toString());
            System.out.println("stu2 "+stu2.toString());
            System.out.println("对象内引用成员是否相等");
            System.out.println("stu1.name ==  stu2.name "+ (stu1.getName() ==  stu2.getName()));
            System.out.println("stu1.age ==  stu2.age "+(stu1.getAge() ==  stu2.getAge()));
            System.out.println("stu1.bag ==  stu2.bag "+(stu1.getBag() ==  stu2.getBag()));
        }
    }
    ```
    输出：
    ```
    两对象是否是同一对象
    stu1 == stu2 false
    stu1 Student{name='小明', age=25, bag=小明的背包}
    stu2 Student{name='小明', age=25, bag=小明的背包}
    对象内引用成员是否相等
    stu1.name ==  stu2.name true
    stu1.age ==  stu2.age true
    stu1.bag ==  stu2.bag true
    ```
    可看出,原对象和克隆对象不是同一对象,克隆对象内的值与原对象相同;对象内引用成员相等,说明只做了引用克隆,不同引用指向同一对象。
    &nbsp;
    **深克隆**：
    1. **多层实现Cloneable类**
        让上述的Bag类也实现Cloneable类,并重写clone方法
        ```java
        public class Bag implements Cloneable{
            private String name;
            public Bag(String name) {
                this.name = name;
            }
            public String getName() {
                return name;
            }
            public void setName(String name) {
                this.name = name;
            }
            @Override
            public Bag clone(){
                Bag bag= null;
                try{
                    bag= (Bag )super.clone();
                } catch (CloneNotSupportedException e){
                    e.printStackTrace();
                }
                return bag;
            }
        }
        ```
        且在Student类的clone方法中执行Bag的clone方法
        ```java
        @Override
        public Student clone(){
            Student stu = null;
            try{
                //浅克隆
                stu = (Student)super.clone();
            } catch (CloneNotSupportedException e){
                e.printStackTrace();
            }
            //深克隆
            stu.bag = (Bag)bag.clone();
            return stu;
        }
        ```
        这样便可实现深克隆,但这种方法很麻烦,若Bag类中还含有成员引用,则又需要再让它实现Cloneable接口重写clone方法,这样代码会显得很臃肿,且繁琐。
        &nbsp;
    2. **利用序列化和反序列化**
        ```java
        public class Student implements Serializable {
            private String name;
            private Integer age;
            private Bag bag;
            ...
            public Student myClone(){
                Student stu = null;
                try {
                    //将对象序列化到流里
                    ByteArrayOutputStream os = new ByteArrayOutputStream();
                    ObjectOutputStream oos = new ObjectOutputStream(os);
                    oos.writeObject(this);
                    //将流反序列化成对象
                    ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
                    ObjectInputStream ois = new ObjectInputStream(is);
                    stu = (Student) ois.readObject();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                }
                return stu;
            }
        }
        ```
        需要注意的是成员引用也需要实现Serializable接口
        ```java
        public class Bag implements Serializable {...}
        ```
        这种方法是利用序列化对象后可将其拷贝到流里,而原对象仍在jvm中,然后从流中将其反序列化成另一个对象到jvm中,从而实现深克隆
        >Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。
        
    
4. **通过序列化机制** <a id="serialization"></a>
    Serializable序列化是将对象转成易于持久化、传输的格式的一种手段，通过将一个对象继承Serializable接口声明该类是可序列化的，然后通过ObjectOutputStream、ObjectInputStream流实现对象的存储与读取、
    &nbsp;
    1. Serializable序列化：
        ```java
        public static void main(String[] args) {
            List<User> userList = new ArrayList<User>();
            userList.add(new User(1, "张三"));
            userList.add(new User(2, "李四"));
            try {
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(userList);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        ```
        执行完成后可在项目根目录看到文件UserSerializeFile。因为是以**二进制的形式进行保存**的，所以以普通文本的形式打开会显示乱码的形式。
        &nbsp;
    2. Serializable反序列化
        ```java
        public static void main(String[] args) {
            try {
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);
                List<User> list = (List<User>) inputStream.readObject();
                for (User user : list) {
                    System.out.println("id: " + user.getId() + " userName: " + user.getUserName());
                }
                inputStream.close();
                fileInputStream.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        ```
        &nbsp;
    3. 部分字段不想序列化，怎么办？
        声明字段时使用transient关键字。无论是序列化还是反序列化，只有添加了transient，序列化运行时会跳过该字段的处理。
        &nbsp;
    4. 要进行序列化的类里的引用，是否需要可序列化？
        需要。要进行序列化的类里如果有引用对象，该对象也需要声明为可序列，即便该对象只含有基本类型的属性，否则会报错误NotSerializableException。
        &nbsp;
    5. 关于序列化多次的问题
        1. 多个对象依次序列化，可以按顺序反序列化取出。:
            ```java
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                //序列化
                User user1 = new User(1, "张三");
                User user2 = new User(2, "李四");
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(user1);
                objOutputStream.writeObject(user2);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");

                //反序列化
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStrea(fileInputStream);
                User user3 = (User)inputStream.readObject();
                User user4 = (User)inputStream.readObject();
                System.out.println("id: " + user3.getId() + " userName: " + user3.getUserName());
                System.out.println("id: " + user4.getId() + " userName: " + user4.getUserName());
                inputStream.close();
                fileInputStream.close();
            }
            ```
            结果：
            ```
            id: 1 name: 张三
            id: 2 name: 李四
            ```
        2. 一个对象序列化后修改属性后再次序列化，结果则是最初的对象属性。
            ```java
            public static void main(String[] args) throws IOException, ClassNotFoundException {
                //序列化
                User user1 = new User(1, "张三");
                FileOutputStream fileOutputStream = new FileOutputStream("UserSerializeFile");
                ObjectOutputStream objOutputStream = new ObjectOutputStream(fileOutputStream);
                objOutputStream.writeObject(user1);
                user1.setUserName("李四");
                objOutputStream.writeObject(user1);
                objOutputStream.close();
                fileOutputStream.close();
                System.out.println("序列化完成");
            
                //反序列化
                FileInputStream fileInputStream = new FileInputStream("UserSerializeFile");
                ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);
                User user3 = (User)inputStream.readObject();
                User user4 = (User)inputStream.readObject();
                System.out.println("id: " + user3.getId() + " userName: " + user3.getUserName());
                System.out.println("id: " + user4.getId() + " userName: " + user4.getUserName());
                inputStream.close();
                fileInputStream.close();
            }
            ```
            结果：
            ```
            id: 1 name: 张三
            id: 1 name: 张三
            ```
            **原因**：
            所有要序列化的对象都有一个序列化的编码号，当试图序列化一个对象，会检查这个对象是否已经序列化过，若从未序列化过，才会序列化为字节序列去输出。若已经序列化过，则会输出一个编码符号，不会重复序列化一个对象。

    6. Externalizable
        1. **Externalizable用法**：
             创建一个ExternalizableDemo类：
            ```java
            import java.io.Externalizable;
            import java.io.IOException;
            import java.io.ObjectInput;
            import java.io.ObjectOutput;

            public class ExternalizableDemo implements Externalizable {
                private static final long serialVersionUID = 1L;
                private String name;
                private int number;

                @Override
                public void writeExternal(ObjectOutput out) throws IOException {
                    out.writeUTF(name);
                    out.writeInt(number);
                }

                @Override
                public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
                    this.name = in.readUTF();
                    this.number = in.readInt();
                }

                public String getName(){
                    return this.name;
                }

                public void setName(String name){
                    this.name = name;
                }

                public int getNumber(){
                    return this.number;
                }

                public void setNumber(int number){
                    this.number = number;
                }
            }
            ```
            定义了一个实现Externalizable接口的 ExternalizableDemo类，在该类中重写了writeExternal()和readExternal()方法
            测试对象序列化和反序列化：
            ```java
            import java.io.*;

            public class ExternalizableTest {
               public static void main(String[] args) {
                   ...
               }

               public static void testExternalizable(String OUTPUT_FILE) throws IOException, ClassNotFoundException {
                   ExternalizableDemo demo = new ExternalizableDemo();
                   demo.setNumber(1004);
                   demo.setName("JIH");
                   ExternalizableDemo seg = new ExternalizableDemo();
            
                   FileOutputStream fileOutputStream = new FileOutputStream(OUTPUT_FILE);
                   ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
                   demo.writeExternal(objectOutputStream);

                   objectOutputStream.flush();
                   objectOutputStream.close();
                   fileOutputStream.close();

                   FileInputStream fileInputStream = new FileInputStream(OUTPUT_FILE);
                   ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
                   seg.readExternal(objectInputStream);
            
                   objectInputStream.close();
                   fileInputStream.close();
               }
            }
            ```

        2. Externalizable与Serializable的异同
            1. 序列化内容
            Externalizable自定义序列化可以控制序列化的过程和决定哪些属性不被序列化。
            &nbsp;
            2. Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器的
            &nbsp;
            3. 使用Externalizable时，必须按照写入时的确切顺序读取所有字段状态。否则会产生异常。例如，如果更改ExternalizableDemo类中的number和name属性的读取顺序，则将抛出java.io.EOFException。而Serializable接口没有这个要求。
### 什么是不可变对象?好处坏处是什么?
+ 不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类；
+ 不可变对象最大的好处是**线程安全**；
+ 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象,**制造大量垃圾**，由于他们不能被重用而且对于它们的使用就是“用”然后“扔”，会创造很多的垃圾，给垃圾收集带来很大的麻烦

### 值传递和引用传递的区别的什么？为什么说Java中只有值传递？
+ 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

+ 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

+ 基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，**只不过“值”为对应的引用**。

### == 和 equals 区别是什么？
1. **==**:
    + 如果==比较的是基本数据类型，那么比较的是两个基本数据类型的值是否相等；
    + 如果==是比较的两个对象，那么比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域；

2. **equals**:
    + equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象
        + 情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
        + 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。

    + java语言规范要求equals方法具有以下特性：
        + **自反性**。对于任意不为null的引用值x，x.equals(x)一定是true。
        + **对称性**。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。
        + **传递性**。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。
        + **一致性**。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。
        + 对于任意不为null的引用值x，**x.equals(null)返回false**。
    
### 为什么要有 hashCode?
+ 以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：
    + 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。
    &nbsp;
    + 但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

### hashCode(),equals()两种方法是什么关系?
+ 如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。
+ 如果两个对象不 equals，他们的 hashCode 有可能相等。
+ 如果两个对象 hashCode 相等，他们不一定 equals。
+ 如果两个对象 hashCode 不相等，他们一定不 equals

### 为什么重写 equals 方法必须重写 hashcode 方法？
+ 因为判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。
&nbsp;
+ 在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。

### String,StringBuffer, StringBuilder 的区别是什么？
||String|StringBuffer|StringBuilder
|-|-|-|-
|**可变性**|不可变|可变|可变
|**执行速度**|最慢|其次|最快
|**线程安全**|安全|安全|不安全
|**使用场景**|少量字符串使用|多线程环境下的大量操作|单线程环境下的大量操作
+ **String:** String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去。
+ **StirngBuffer:** StringBuffer相对于StringBuilder效率要相对低一点，但也远比String要高的多。效率低的原因：对于StringBuffer来说更多的考虑到了多线程的情况，在进行字符串操作的时候，它**使用了synchronize关键字**，对方法进行了同步处理。
因此StringBuffer适用于多线程环境下的大量操作。
+ **StringBuilder:** 对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程的环境下对同一个StringBuilder对象进行操作。
因此StringBuilder适用于单线程环境下的大量字符串操作。

### String为什么要设计成不可变的？
1. 便于实现字符串池（String pool）
    在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了**String pool**的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。
    如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！
    &nbsp;
2. 使多线程安全
    在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。
    &nbsp;
3. 避免安全问题
    在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。
    &nbsp;
4. 加快字符串处理速度
    由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。

### 什么是字符串常量池？
+ jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。
+ 全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。

### String str="aaa"与 String str=new String("aaa")一样吗？new String(“aaa”);创建了几个字符串对象?
+ 使用String a = “aaa” ;程序运行时会**在字符串常量池中查找“aaa”字符串**，若没有，会将“aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。
+ 使用String b = new String("aaa");`，程序**会在堆内存中开辟一片新空间存放新对象**，不会将“aaa”字符串放入常量池，无论常量池中有没有“aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。

### intern()方法
+ 当调用 intern() 方法时，如果字符串池中已经存在相同内容的字符串，则返回字符串池中的引用；否则，将该字符串添加到字符串池中，并返回对字符串池中的新引用。

+ 例：
    ```java
    String a = new String("ab");
    String b = new String("ab");
    String c = "ab";
    String d = "a" + "b";
    String e = "b";
    String f = "a" + e;

    System.out.println(b.intern() == a);
    System.out.println(b.intern() == c);
    System.out.println(b.intern() == d);
    System.out.println(b.intern() == f);
    System.out.println(b.intern() == a.intern());
    ```
    运行结果：
    ```
    false
    true
    true
    false
    true
    ```
    由运行结果可以看出来，b.intern() == a和b.intern() == c可知，**采用new 创建的字符串对象不进入字符串池，** 并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，**如果其中含有变量（如f中的e）则不会进入字符串池中**。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。

### 在使用 HashMap 的时候，用 String 做 key 有什么好处？
HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

### 包装类型是什么？基本类型和包装类型有什么区别？
+ 与基本数据类型对应的类。
+ 区别：
    + 包装类型可以为 null，而基本类型不可以。
    + 包装类型可用于泛型，而基本类型不可以。
    + 基本类型比包装类型更高效。

### 解释一下自动装箱和自动拆箱？
+ 自动装箱：将基本数据类型重新转化为对象
+ 自动拆箱：将对象重新转化为基本数据类型

### Integer和int之间的==比较
1. **两个new生成的Integer变量的对比**
    由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。
    &nbsp;
2. **Integer变量和int变量的对比**
    Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）
    &nbsp;
3. **非new生成的Integer变量和new Integer()生成变量的对比**
    非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）
    ```java
    Integer b = new Integer(10000);
    Integer c=10000;
    System.out.println(b == c); // false
    ```
    &nbsp;
4. **两个非new生成的Integer对象的对比**
    对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false
    ```java
    Integer i = 100;
    Integer j = 100;
    System.out.print(i == j); //true

    Integer i = 128;
    Integer j = 128;
    System.out.print(i == j); //false
    ```
    当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。

### 什么是反射？
反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

### 反射机制的优缺点有哪些？
+ 优点：能够运行时动态获取类的实例，提高灵活性；可与动态编译结合Class.forName('com.mysql.jdbc.Driver.class');，加载MySQL的驱动类。

+ 缺点：使用反射**性能较低**，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。

### 如何获取反射中的Class对象？
1. Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。
Class clz = Class.forName("java.lang.String");
&nbsp;
2. 类名.class。这种方法只适合在编译前就知道操作的 Class。
Class clz = String.class;
&nbsp;
3. 对象名.getClass()。
String str = new String("Hello"); Class clz = str.getClass();
&nbsp;
4. 如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。

### Java反射API有几类？
反射 API 用来生成 JVM 中的类、接口或则对象的信息。

+ Class 类：反射的核心类，可以获取类的属性，方法等信息。
+ Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。
+ Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。
+ Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。

### 反射使用的步骤？
1. 获取类的 Class 对象实例
    ```java 
    Class clz = Class.forName("com.zhenai.api.Apple");
    ```
2. 根据 Class 对象实例获取 Constructor 对象
    ```java
    Constructor appleConstructor = clz.getConstructor();
    ```
3. 使用 Constructor 对象的 newInstance 方法获取反射类对象
    ```java
    Object appleObj = appleConstructor.newInstance();
    ```
4. 而如果要调用某一个方法，则需要经过下面的步骤：
    1. 获取方法的 Method 对象
        ```java
        Method setPriceMethod = clz.getMethod("setPrice", int.class);
        ```
    2. 利用 invoke 方法调用方法
        ```java
        setPriceMethod.invoke(appleObj, 14);
        ```

例子：
```java
public class Apple {

    private int price;

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public static void main(String[] args) throws Exception{
        //正常的调用
        Apple apple = new Apple();
        apple.setPrice(5);
        System.out.println("Apple Price:" + apple.getPrice());
        //使用反射调用
        Class clz = Class.forName("com.chenshuyi.api.Apple");
        Method setPriceMethod = clz.getMethod("setPrice", int.class);
        Constructor appleConstructor = clz.getConstructor();
        Object appleObj = appleConstructor.newInstance();
        setPriceMethod.invoke(appleObj, 14);
        Method getPriceMethod = clz.getMethod("getPrice");
        System.out.println("Apple Price:" + getPriceMethod.invoke(appleObj));
    }
}
```
### Java中的泛型是什么 ?
泛型就是将类型参数化，其在编译时才确定具体的参数。

### 使用泛型的好处是什么?
1. 类型安全： 泛型在编译时提供了类型检查，可以在编译阶段捕获类型错误，而不是在运行时抛出异常。

2. 代码复用： 泛型可以编写更通用、可复用的代码，减少代码的冗余。

3. 可读性： 泛型使得代码更加清晰，可以在代码中看到操作的数据类型，提高代码的可读性。

4. 更好的性能： 泛型的类型检查是在编译时进行的，不需要运行时的类型检查，因此可以提高程序的性能。

### 什么是泛型中的限定通配符和非限定通配符 ?
+ 限定通配符：
    + ``<? extends T>``它通过确保类型必须是T的子类来设定类型的上界
    + ``<? super T>``它通过确保类型必须是T的父类来设定类型的下界。
+ 非限定通配符：
    + 非限定通配符 ``?``,可以用任意类型来替代。如 ``List<?>`` 的意思是这个集合是一个可以持有任意类型的集合

### Java序列化与反序列化是什么？
+ Java序列化是指把Java对象转换为字节序列的过程
+ Java反序列化是指把字节序列恢复为Java对象的过程

###  为什么需要序列化与反序列化？
对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化

### 序列化实现的方式有哪些？
实现Serializable接口或者Externalizable接口。
[具体用法及相关问题](#serialization)

### 为什么还要显示指定serialVersionUID的值?
如果不显示指定serialVersionUID, JVM在序列化时会**根据属性自动生成**一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会**再根据属性自动生成**一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较, 如果相同则反序列化成功, 否则报错.

如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.

在实际开发中, 不显示指定serialVersionUID的情况会导致什么问题? 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, **一旦类被修改了, 那旧对象反序列化就会报错**.

### 静态变量会被序列化吗?
不会。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.

### Error 和 Exception 区别是什么？
+ **Exception** : 程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。
+ **Error** ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。

### throw 和 throws 的区别是什么？
+ throw 关键字**用在方法内部**，只能用于抛出一种异常，用来抛出方法或代码块中的异常，**受查异常和非受查异常都可以被抛出**。
+ throws 关键字**用在方法声明上**，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中**必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常**。

### NoClassDefFoundError 和 ClassNotFoundException 区别？
+ NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致。
&nbsp;
+ ClassNotFoundException 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。

### try-catch-finally 中哪个部分可以省略？
可以省略catch或者finally。catch和finally不可以同时省略。

### 如果 catch 中 return 了，finally 还会执行吗？
会。
1. finally的作用就是，无论出现什么状况，finally里的代码一定会被执行。
2. 如果在catch中return了，也会在return之前，先执行finally代码块。
3. 而且如果finally代码块中含有return语句，会覆盖其他地方的return。
4. 对于基本数据类型的数据，在finally块中改变return的值对返回值没有影响，而对引用数据类型的数据会有影响。

### 什么情形下，finally代码块不会执行？
1. 没有进入try代码块；
2. System.exit()强制退出程序；
3. 守护线程被终止；

### JVM 是如何处理异常的？
在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。

JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。

## Java多线程
### 线程和进程的区别
+ 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。
+ 线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

### 什么是并行与并发
+ 并发是指一个处理器同时处理多个任务。
+ 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。

### 并发编程的3个基本概念
1. 原子性
定义： 即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
2. 可见性
定义：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性
定义：即程序执行的顺序按照代码的先后顺序执行。

### 线程有哪些状态？
+ 新建
当一个Thread类或其子类对象被声明并创建时，新生的线程处于新建状态

+ 就绪
处于新建状态的线程调用start()方法后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，只是没分配到CPU资源，此时的线程处于就绪状态

+ 运行
处于就绪状态的线程被调度并获得CPU资源时,便进入运行状态，执行run()方法中的代码

+ 阻塞
正在运行的线程被人为挂起或执行输入输出操作时，如调用sleep、wait、suspend等方法后，让出CPU并临时中止自己的执行，进入阻塞状态

+ 死亡
当线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法让它进入就绪状态

### 什么是上下文切换?
线程在执行过程中会有**自己的运行条件和状态**，也称上下文，当出现如下情况的时候，线程会从占用 CPU 状态中退出：

+ 主动让出 CPU，比如调用了 sleep(), wait()等。

+ 时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。

+ 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。

+ 被终止或结束运行

这其中**前三种都会发生线程切换**，线程切换意味着需要**保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场，并加载下一个将要占用 CPU 的线程上下文**，这就是上下文切换。


### 线程切换要保存哪些上下文？
线程在切换的过程中需要保存**当前线程id、线程状态、堆栈、寄存器状态等信息**。其中寄存器主要包括SP、PC、EAX等寄存器，其主要功能如下：

**SP**:堆栈指针，指向当前栈的栈顶地址

**PC**:程序计数器，存储下一条将要执行的指令

**EAX**:累加寄存器，用于加法乘法的缺省寄存器

### 什么是线程安全？
线程安全就是某个函数在并发环境中调用时，能够处理好多个线程之间的共享变量，是程序能够正确执行完毕。也就是说我们想要确保在多线程访问的时候，我们的程序还能够按照我们的预期的行为去执行，那么就是线程安全了。

### 守护线程是什么？
守护线程（即daemon thread），是服务线程，准确地来说就是服务其他的线程。

### 什么是死锁？
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 为什么不能直接调用run()方法？
因为调用start()方法才能启动线程并让线程进入就绪状态，直接执行run()方法的话不会以多线程的方式执行，只会把 run()方法当成一个 main 线程下的普通方法去执行。

### 创建多线程的方式
1. 继承Thread类的方式
创建一个继承于Thread类的子类
重写Thread类的run()-->将此线程执行的操作声明在run()中
创建Thread类的子类的对象
通过此对象调用start()：①启动当前线程②调用当前线程的run()
```java
public class ThreadDemo {
    public static void main(String[] args) {
        //设置线程名字，不设置则使用默认构造 0 1 2 3...这样
        Thread.currentThread().setName("主线程");
        MyThread myThread = new MyThread();
        myThread.setName("子线程:");
        //开启线程
        myThread.start();
        for(int i = 0;i<5;i++){
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
}
 
//实现方式之继承Thread
class MyThread extends Thread{
    //重写run()方法
    public void run(){
        for(int i = 0;i < 5; i++){
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
}
```
2. 实现Runnable接口的方式
创建一个实现了Runnable接口的类
实现类去实现Runnable中的抽象方法：run()
创建实现类的对象
将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
通过Thread类的对象调用start()
```java
public class RunnableDemo {
    public static void main(String[] args) {
	    //设置线程名字，不设置则使用默认构造 0 1 2 3...这样
	    Thread.currentThread().setName("主线程");
	    Thread myThread = new Thread(new MyRunnable());//作为参数传入
	    myThread.setName("实现Runnable接口方式，子线程:");
	    //开启线程
	    myThread.start();
	    for(int i = 0;i<5;i++){
	        System.out.println(Thread.currentThread().getName() + i);
	    }
	}
}
 
//实现方式之实现Runnable
class MyRunnable implements Runnable{
    //重写run()方法
    public void run(){
        for(int i = 0;i < 5; i++){
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
}
```
3. 实现Callable接口
创建一个实现Callable的实现类
实现call方法，将此线程需要执行的操作声明在call()中
创建Callable接口实现类的对象
将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
使用get()方法获取Callable中call方法的返回值。get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
```java
public class CallableDemo implements Callable<Integer>{
	public static void main(String[] args) {
		CallableDemo demo = new CallableDemo();
		//执行Callable 方式，需要FutureTask 实现实现，用于接收运算结果
		FutureTask<Integer> task = new FutureTask<>(demo);//代码规范，泛型写一边即可。
		Thread t = new Thread(task);
		t.start();
		System.out.println("主线程可以做点别的，等待demo计算的返回结果，下面设置了2秒的等待");
		Integer res = 0;
		try {
			res = task.get();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("通过实现接口方式线程返回结果:" + res);
	}
 
	//相当于 Thread里面的run()方法
	@Override
	public Integer call() throws Exception {
		System.out.println("业务处理...");
		Thread.sleep(2000);//毫秒
		return 1;//返回值
	}
}
```
4. 使用线程池
```java
public class ThreadPoolDemo {
	public static void main(String[] args) {
		//Executor还有其他很多之类，可以根据 自己需求使用
		Executor threadPool = Executors.newFixedThreadPool(5);//创建一个5个线程的线程池
		//向线程池里面提交10个任务
		for(int i = 0;i < 10; i++){
			threadPool.execute(new Runnable(){
					@Override
					public void run() {
						System.out.println(Thread.currentThread().getName());
					}
			});
		}
	}
}
```
任务使用的线程始终是创建的线程池里面的五个线程。而不是十个线程，**五个线程循环使用**，处理完了，继续处理下一个任务。

### Thread类和Runable接口的最大区别是什么？
Thread是类，Runable是接口，实现的方式没有类的单继承性的局限性.
Thread实现了Runnable接口，提供了更多的可用方法和成员。
二者没有本质上的区别。

### 说说 sleep()方法和 wait()方法区别和共同点?
两者都可以暂停线程的执行。

两者最主要的区别在于：sleep()方法没有释放锁，而 wait()方法释放了锁。

wait()通常被用于线程间交互/通信，sleep()通常被用于暂停执行。

wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。

### Java中同步机制有几种方式
1. **同步代码块**
    处理实现Runnable安全问题，Thread实现类实现的话，需要加static保证当前对象的唯一性）
    ```java
    synchronized(/*同步监视器*/){
    //需要被同步的代码
    }
    ```
    说明： 
    1.操作共享数据的代码，即为需要被同步的代码
    2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。
    3.同步监视器：俗称锁。任何一个类的对象，都可以充当锁。
    要求： 多个线程必须要公用同一把锁
    例子：
    ```java
    class Windows implements Runnable{
    private int tickets = 100;
    private Object ob = new Object(); //线程的同一把锁，即同一个对象
        @Override
        public void run() {
            while (true) {
                synchronized(ob) {  //通过synchronized来加锁  
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + ":买票,票号为：" + tickets);
                        tickets--;
                    } else {
                        break;
                    }
                }
            }
        }
    }
    ```
    + synchronized（this）和synchronized（.class）的理解
        对象锁（this）和类锁(class)产生的效果不同，对象锁只对当前对象加锁，而类锁是对指定类加锁。

        1. synchronized（this）锁的是当前对象，this代表了对象锁，此时被synchronized锁住的代码块只在当前对象同步，如果有其他对象就不会同步了。

        2. synchronized（.class）是一个类锁，对整个类进行加锁。在this的基础上还可以对同一类的不同对象进行同步。
2. **同步方法**
    关于同步方法总结：
    1. 同步方法仍然涉及到同步监器，只是不需要我门显示的声明。
    2. 非静态同步方法，同步监视器是this
        静态的同步方法，同步监视器是：当前类本身

    ```java
    class Windows implements Runnable{
        private int tickets = 100;
        @Override
        public void run() {
            while (true) {
                way();
            }
        }
        public synchronized void way() {  //通过synchronized来加锁,代表的是this当前的Windows类
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + ":买票,票号为：" + tickets);
                tickets--;
            }
        }
    }
    ```

3. **Lock()锁**
    ```java
    class Windowt implements Runnable {
        private int ticktes = 100;
        private ReentrantLock lock = new ReentrantLock();
        @Override
        public void run() {
            while (true) {
                try{
                    //加放锁
                    lock.lock();
                    if (ticktes > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "当前的票数为：" + ticktes);
                        ticktes--;
                    } else {
                        break;
                    }
                }finally {
                    //释放锁
                    lock.unlock();
                }
            }
        }
    }
    ```

### synchronized 与 Lock的异同？
+ 相同：二者都可以解决线程安全问题
+ 不同：
Lock 是显式锁，需要手动开启和关闭，synchronized是隐式锁，出了作用域自动释放
Lock只有代码块锁，synchronized有代码块锁和方法锁
使用Lock锁， JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

### volatile 关键字的作用？
+ 禁止指令重排序：volatile变量的修饰使得JVM在生成字节码时会在该变量的读写前后插入内存屏障，从而避免了指令的乱序执行问题。
+ 保证变量的可见性：当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
+ 不保证原子性：volatile不能替代synchronized来保证原子性。例如，count++这样的操作实际上是由读取-修改-写入三步组成，而volatile只能保证单个读操作和写操作是原子的，不能保证复合操作的原子性。

### 单例模式的双重锁为什么要加volatile？
```java
public class TestInstance{
  private volatile static TestInstance instance;
  public static TestInstance getInstance(){   //1
    if(instance == null){   //2
      synchronized(TestInstance.class){   //3
        if(instance == null){   //4
          instance = new TestInstance(); //5
        }
      }
    }
    return instance;   //6
  }
}
```

+ **如果不加volatile**
``singleton = new Singleton();``
该语句非原子操作，实际是三个步骤。
1.给singleton分配内存；
2.调用 Singleton 的构造函数来初始化成员变量；
3.将给singleton对象指向分配的内存空间（此时singleton才不为null）；
虚拟机进行指令重排序–>
执行命令时虚拟机可能会对以上3个步骤交换位置，最后可能是132这种，分配内存并修改指针后未初始化，多线程获取时可能会出现问题。

+ **加了volatile**
如果字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的，同时还会禁止指令重排序，防止出现上述问题。


### synchronized 关键字和 volatile 关键字的区别？
synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在。
+ volatile 关键字是线程同步的轻量级实现，所以 volatile性能比synchronized关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。
+ volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
+ volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

### ThreadLocal 是干嘛的？
ThreadLocal实现了每个线程都有自己的专属本地变量，可以将ThreadLocal类比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

### 如何创建线程池？/创建线程池有哪几种方式？/线程池哪几种?
+ **newFixedThreadPool(int nThreads)/FixedThreadPool**
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

+ **newCachedThreadPool()/CachedThreadPool**
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

+ **newSingleThreadExecutor()/SingleThreadExecutor**
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；特点是能确保依照任务在队列中的顺序来串行执行。

+ **newScheduledThreadPool(int corePoolSize)/ScheduledThreadPool**
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

### 执行 execute()方法和 submit()方法的区别是什么呢？
+ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功；
+ submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值。

### 线程池都有哪些状态？
1. **RUNNING**
    + 线程池处于RUNNING状态时，线程池能够接收新任务，也能够对已经添加的任务进行处理；
    + 线程池一被创建，线程池的状态就是RUNNING状态；

2. **SHUTDOWN**
    + 线程池已经被关闭了，不再接收新任务；但是，其还是会处理队列中的剩余的任务；
    + 调用线程池的shutdown()方法后，线程池的状态就会由RUNNING转为SHUTDOWN；

3. **STOP**
    + 线程池处于STOP状态，此时线程池不再接收新任务，不处理已经添加进来的任务，并且会中断正在处理的任务； 
    + 调用线程池的shutdownNow()方法后，线程池的状态就会由RUNNING或SHUTDOWN转为STOP；

4. **TIDYING**
    + 线程池被下达关闭命令后，如果当前所有的任务都已经终止了（这个终止可以表示执行结束，也可以表示强制中断，也可以表示被丢弃） ，那么线程就会进入TIDYING状态；当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
    + 如果线程状态已经是SHUTDOWN了，并且线程中以及队列中都没有任务时，线程池就会由SHUTDOWN转为TIDYING；如果线程池状态为STOP，那么当线程池把所有的任务都给清理干净时，线程池就会由STOP转为TIDYING；

5. **TERMINATED**
    + 线程池就结束了；线程池就不能重新启动了；
    + 如果线程池处于TIDYING状态，那么当线程池执行完terminated()方法后，线程池状态就会由TIDYING转为TERMINTED；

    ![示例图](/assets/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJT1B3UFRLSkpYYW9ydzFGSk1OUkthT2libXBwZG04R0lpYjAwUUNneWliclZoRmNVNHR2akFCb1lCVUtpYlZFZlE5VXZBdlQwbGliV0E5TFdnLzY0MA.png)

### shutdown()和shutdownNow()的区别是什么？
shutdown（）:关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。

shutdownNow（）:关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。

### 线程池的拒绝策略有哪几种？
+ 若线程池中的核心线程数被用完且阻塞队列已满，则此时线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。

jdk内置的拒绝策略有4种：
+ AbortPolicy：直接抛出异常，组织线程正常运行
+ CallerRunsPolicy ：如果被丢弃的线程任务未关闭，则执行该线程任务
+ DiscardOldestPolicy：移除线程队列中最早的一个线程任务，并尝试提交当前任务
+ DiscardPolicy：丢弃当前的线程任务而不做任何处理。
默认的拒绝策略在ThreadPoolExecutor中作为内部类提供。

### Atomic的原理？
AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

Atomic原子类底层用的不是传统意义的锁机制，而是无锁化的CAS机制，通过CAS机制保证多线程修改一个数值的安全性。

CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。

