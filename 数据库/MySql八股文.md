# MySql八股文
## MySql基础
### 数据库的三范式是什么？
+ 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
+ 第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。
+ 第三范式：任何非主属性不依赖于其它非主属性。

### SQL 约束有哪几种？
+ NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
+ UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
+ PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
+ FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
+ CHECK: 用于控制字段的值范围。

### MySQL中 in 和 exists 区别
MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。

如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则**子查询表大的用exists，子查询表小的用in**。 not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。**所以无论那个表大，用not exists都比not in要快**。

### SQL语言的四种分类？
1. **DDL(Data Definition Language，数据定义语言)**
主要用于维护存储数据的结构，这种结构包括数据库，表、视图、索引、同义词、聚簇等。
+ 代表指令：
    + create 创建数据库和数据库的一些对象
    + drop 删除数据库/表、索引、条件约束以及数据表的权限等
    + alter 修改数据库表的定义及数据属性
2. **DML(Data Manipulation Language，数据操纵语言)**
主要用于对数据库对象中包含的数据进行操作
+ 代表指令：
    + insert 向数据库中插入一条数据
    + delete 删除表中的一条或者多条记录
    + updata 修改表中的数据
3. **DQL(Data Query Language，数据查询语言)**
主要用于查询数据库当中的数据
+ 代表指令：
    + selete 查询表中的数据
    + from 查询哪张表、视图
    + where 约束条件
4. **DCL(Data Control Language，数据控制语言)**
主要控制数据库对象的权限管理、事务和实时监视。
+ 代表指令：
    + grant分配权限给用户
    + revoke废除数据库中某用户的权限
    + rollback 退回到某一点(回滚）
    + commit 提交

### drop、delete与truncate的区别
三者都表示删除，但是三者有一些差别：
||drop|delete|truncate
|-|-|-|-|
速度|快|逐行删除，慢|较快
类型|DDL|DML|DDL
回滚|不可回滚|可回滚|不可回滚
删除内容|删除整个表，数据行、索引都会被删除|表结构还在，删除表的一部分或全部数据|表结构还在，删除表的全部数据

### 图解数据库左连接、右连接、内连接、外连接、全连接的区别
+ 内连接(inner join)
    内连接查询的是两张表的并集，也就是A表和B表都必须有数据才能查询出来；
    ![3b601af171e74b738e9fefd0de731a44](/assets/3b601af171e74b738e9fefd0de731a44.png)
    ```sql
    -- inner join
    select * from A inner join B on A.id = B.id 

    -- 逗号的连表方式就是内连接
    select * from A , B where A.id = B.id 
    ```

+ 左连接(left join)
    是以左表为基础，根据ON后给出的两表的条件将两表连接起来。结果会将左表所有的查询信息列出，而右表只列出ON后条件与左表满足的部分。左连接全称为左外连接，是外连接的一种。
    ![deae9b734a4b4a878a6cf2ec317304ea](/assets/deae9b734a4b4a878a6cf2ec317304ea.png)
    ```sql
    -- left join
    select * from A left join B on  A.id = B.id 
    ```

+ 右连接(right join)
    是以右表为基础，根据ON后给出的两表的条件将两表连接起来。结果会将右表所有的查询信息列出，而左表只列出ON后条件与右表满足的部分。右连接全称为右外连接，是外连接的一种。
    ![31d67d01a3d44874872dbe6e86c7536b](/assets/31d67d01a3d44874872dbe6e86c7536b.png)
    ```sql
    -- right join
    select * from A right join B on  A.id = B.id 
    ```

+ 全连接(mysql中没有，但是可以使用union表示)
    全连接显示两侧表中所有满足检索条件的行。
    ![f0e6e5201ec54ace8ff95db15457d0f2](/assets/f0e6e5201ec54ace8ff95db15457d0f2.png)
    ```sql
    select * from a left join b on a.id = b.id
    union
    select * from a right join b on a.id = b.id
    ```

### 什么是脏读？幻读？不可重复读？
1. 脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据

2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。

3. 幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

### 数据库的乐观锁和悲观锁是什么？怎么实现的？
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

+ 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
+ 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。

### 超大分页怎么处理?
数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于
```sql
select * from table where age > 20 limit 1000000,10
```
这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃,只取 10 条当然比较慢. 当时我们可以修改为
```sql
select * from table where id in (select id from table where age > 20 limit 1000000,10)
```
这样虽然也 load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。